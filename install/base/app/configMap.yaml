---
# Source: splunk-connect-for-kubernetes/charts/splunk-kubernetes-objects/templates/configMap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-audit-logging
  labels:
    app.kubernetes.io/component: collection
data:
  opa.conf: |
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "status.gatekeeper.sh/v1beta1"
      insecure_ssl false
      <watch>
        resource_name constraint_template_pod_statuses
      </watch>
      <watch>
        resource_name constraint_pod_statuses
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "templates.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name constraint_templates
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "config.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name configs
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "constraints.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name k8s_required_probes
      </watch>
      <watch>
        resource_name k8s_no_annotation_values
      </watch>
      <watch>
        resource_name k8s_required_label_values
      </watch>
        <watch>
        resource_name k8s_allowed_repos
      </watch>
      <watch>
        resource_name k8s_banned_image_tags
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag opa.violations.*
      api_version "constraints.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name k8s_required_probes
      </watch>
      <watch>
        resource_name k8s_no_annotation_values
      </watch>
      <watch>
        resource_name k8s_required_label_values
      </watch>
      <watch>
        resource_name k8s_allowed_repos
      </watch>
      <watch>
        resource_name k8s_banned_image_tags
      </watch>
    </source>
  pods.conf: |
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "v1"
      insecure_ssl false
      <watch>
        resource_name pods
      </watch>
      <watch>
        resource_name namespaces
      </watch>
      <watch>
        resource_name events
      </watch>
    </source>
  outputs.conf: |
    <match kube.**>
      @type elasticsearch
      include_tag_key true
      port 9200
      scheme https
      ca_file /etc/elasticsearch/certs/ca.crt
      host elasticsearch-es-http
      user elastic
      password "#{ENV['ELASTIC_PASSWORD']}"
      reload_connections true
      reload_after 100
      loglevel debug
      logstash_format true
      logstash_prefix objects
    </match>
    <match violations.**>
      @type elasticsearch
      include_tag_key true
      port 9200
      scheme https
      ca_file /etc/elasticsearch/certs/ca.crt
      host elasticsearch-es-http
      user elastic
      password "#{ENV['ELASTIC_PASSWORD']}"
      reload_connections true
      reload_after 100
      loglevel debug
      logstash_format true
      logstash_prefix violations
    </match>
    <match>
      @type stdout
    </match>
  filters.conf: |
    <filter kube.objects.pods>
      @type jq_transformer
      # in ruby '\\' will escape and become just '\', since we need two '\' in the `gsub` jq filter, it becomes '\\\\'.
      jq '.record.source = "namespace:\(env.MY_NAMESPACE)/pod:\(env.MY_POD_NAME)" | .record.sourcetype = (.tag | gsub("\\\\."; ":")) | .record'
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.state = [ .record.object.status.containerStatuses | .[0]? | select(has("state")) |  .state | keys[]  ]| .record '
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.reason = [ .record.object.status.containerStatuses | .[0]?.state | .. | .reason?  | select (. !=null) ] | .record '
      @id pod_reason
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.images = [ .record.object.status.containerStatuses | .[]?.image ] | .record'
      @id pod_image
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.imageIDs = [.record.object.status.containerStatuses | .[]?.imageID ] | .record '
      @id pod_image_id
    </filter>

    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.phase = [.record.object.status.phase ] | .record '
      @id pod_phase
    </filter>

    # variable status fields cause input errors. So we extracted the values we want above 
    # and then clear out the rest of the status here:
    <filter kube.objects.*>
      @type record_transformer
      remove_keys $.object.metadata.managedFields
      @id remove_managed_fields
    </filter>

    <match opa.violations.*>
      @type jq
      # jq 'select( .record.object.status.totalViolations != 0 ) |  .record.object.status.violations'
      jq '.record.object.status.violations'
      # tag violations.*
      label @VIOLATIONS
      remove_tag_prefix opa
      @id violations_extraction
    </match>
    # This replaces all . with _ in labels/annotations/etc.  This causes issues when there are multiple labels in the environment:
    # app: foo and app.kubernetes.io/something: foo since app is both a field and an object, so Elasticsearch cannot
    # understand how to parse
    <filter kube.**>
      @type dedot
      @id test_dedot
      de_dot_nested true
      de_dot_separator _
    </filter>
  fluent.conf: |
    <system>
      log_level info
    </system>
    @include pods.conf
    @include opa.conf
    @include filters.conf
    @include outputs.conf




