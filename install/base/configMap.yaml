---
# Source: splunk-connect-for-kubernetes/charts/splunk-kubernetes-objects/templates/configMap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-audit-logging
  labels:
    app.kubernetes.io/component: collection
data:
  opa.conf: |
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "status.gatekeeper.sh/v1beta1"
      insecure_ssl false
      <watch>
        resource_name constraint_template_pod_statuses
      </watch>
      <watch>
        resource_name constraint_pod_statuses
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "templates.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name constraint_templates
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "config.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name configs
      </watch>
    </source>
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "constraints.gatekeeper.sh/v1alpha1"
      insecure_ssl false
      <watch>
        resource_name k8s_required_probes
      </watch>
      <watch>
        resource_name k8s_no_annotation_values
      </watch>
      <watch>
        resource_name k8s_required_label_values
      </watch>
        <watch>
        resource_name k8s_allowed_repos
      </watch>
    </source>
  pods.conf: |
    <source>
      @type kubernetes_objects
      tag kube.objects.*
      api_version "v1"
      insecure_ssl false
      <watch>
        resource_name pods
      </watch>
    </source>
  outputs.conf: |
    <match kube.objects.*>
      @type elasticsearch
      include_tag_key true
      port 9200
      scheme https
      ca_file /etc/elasticsearch/certs/ca.crt
      host elasticsearch-es-http
      user elastic
      password "#{ENV['ELASTIC_PASSWORD']}"
      reload_connections true
      reload_after 100
      loglevel debug
      logstash_format true
      logstash_prefix pods
    </match>
    <match opa.objects.*>
      @type stdout
    </match>
    <match opa.objects.**>
      @type elasticsearch
      include_tag_key true
      port 9200
      scheme https
      ca_file /etc/elasticsearch/certs/ca.crt
      host elasticsearch-es-http
      user elastic
      password "#{ENV['ELASTIC_PASSWORD']}"
      reload_connections true
      reload_after 100
      loglevel debug
      logstash_format true
      logstash_prefix opa
    </match>
  filters.conf: |
    <filter kube.**>
      @type jq_transformer
      # in ruby '\\' will escape and become just '\', since we need two '\' in the `gsub` jq filter, it becomes '\\\\'.
      jq '.record.source = "namespace:\(env.MY_NAMESPACE)/pod:\(env.MY_POD_NAME)" | .record.sourcetype = (.tag | gsub("\\\\."; ":")) | .record'
    </filter>

    # # | jq '. | select(.status.violations != null) |  {name: .metadata.name, kind: .kind, apiVersion: .apiVersion, spec: .spec, violation: .status.violations[] }'
    # <filter kube.objects.k8s_allowed_repos>
    #   @type jq_transformer
    #   jq '.record.violations = ". | select(.record.object.status.violations != null)  | {name: .record.object.metadata.name, kind: .record.object.kind, apiVersion: .record.object.apiVersion, spec: .record.object.spec, totalViolations: .record.object.status.totalViolations, violation: .record.object.status.violations?[] } | .record '
    # </filter>

    # <match kube.objects.k8s_allowed_repos>
    #   @type jq
    #   jq .record.violations
    #   remove_tag_prefix kube.objects
    # </match>

    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.state = [ .record.object.status.containerStatuses | .[0]? | select(has("state")) |  .state | keys[]  ]| .record '
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.reason = [ .record.object.status.containerStatuses | .[0]?.state | .. | .reason?  | select (. !=null) ] | .record '
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.images = [ .record.object.status.containerStatuses | .[]?.image ] | .record'
    </filter>
    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.imageIDs = [.record.object.status.containerStatuses | .[]?.imageID ] | .record '
    </filter>

    <filter kube.objects.pods>
      @type jq_transformer
      jq '.record.phase = [.record.object.status.phase ] | .record '
    </filter>

    # variable status fields cause input errors. So we extracted the values we want above 
    # and then clear out the rest of the status here:
    <filter kube.objects.*>
      @type record_transformer
      remove_keys $.object.metadata.managedFields
    </filter>
    <filter opa.objects.*>
      @type record_transformer
      remove_keys $.object.metadata.managedFields
    </filter>

    # This replaces all . with _ in labels/annotations/etc.  This causes issues when there are multiple labels in the environment:
    # app: foo and app.kubernetes.io/something: foo since app is both a field and an object, so Elasticsearch cannot
    # understand how to parse
    <filter **>
      @type dedot
      @id test_dedot
      de_dot_nested true
      de_dot_separator _
    </filter>
  fluent.conf: |
    <system>
      log_level info
    </system>
    @include pods.conf
    @include opa.conf
    @include filters.conf
    @include outputs.conf




